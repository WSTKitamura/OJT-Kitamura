<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>3D背景＋避けゲー</title>
    <style>
      body,
      html {
        margin: 0;
        padding: 0;
        overflow: hidden;
        font-family: sans-serif;
        height: 100vh;
        background: #000;
      }
      #bgCanvas,
      #gameCanvas {
        position: fixed;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        display: block;
      }
      #bgCanvas {
        z-index: 0;
      }
      #gameCanvas {
        z-index: 1;
        pointer-events: auto;
        background: transparent;
      }
      #score {
        position: fixed;
        top: 10px;
        left: 10px;
        color: white;
        font-size: 20px;
        font-weight: bold;
        z-index: 2;
        text-shadow: 0 0 5px black;
      }
    </style>
  </head>
  <body>
    <canvas id="bgCanvas"></canvas>
    <canvas id="gameCanvas"></canvas>
    <div id="score">SCORE: 0</div>

    <script src="https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.min.js"></script>
    <script>
      // === Three.js 3D背景設定 ===
      const bgCanvas = document.getElementById("bgCanvas");
      const renderer = new THREE.WebGLRenderer({
        canvas: bgCanvas,
        antialias: true,
        alpha: false,
      });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setClearColor(0x0a0a0a);

      const scene = new THREE.Scene();
      const camera = new THREE.PerspectiveCamera(
        75,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
      );
      camera.position.z = 6;

      // 立方体群を作る
      const cubes = [];
      const cubeCount = 50;
      for (let i = 0; i < cubeCount; i++) {
        const geo = new THREE.BoxGeometry(0.3, 0.3, 0.3);
        const mat = new THREE.MeshStandardMaterial({
          color: new THREE.Color(Math.random(), Math.random(), Math.random()),
        });
        const cube = new THREE.Mesh(geo, mat);
        cube.position.set(
          (Math.random() - 0.5) * 12,
          (Math.random() - 0.5) * 8,
          (Math.random() - 0.5) * 12
        );
        scene.add(cube);
        cubes.push(cube);
      }

      // 環境光 + ポイントライト
      const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
      scene.add(ambientLight);
      const pointLight = new THREE.PointLight(0xffffff, 0.8);
      pointLight.position.set(5, 5, 5);
      scene.add(pointLight);

      function animateBG() {
        requestAnimationFrame(animateBG);
        cubes.forEach((c, i) => {
          c.rotation.x += 0.01 + i * 0.0003;
          c.rotation.y += 0.01 + i * 0.0005;
        });
        renderer.render(scene, camera);
      }
      animateBG();

      // リサイズ対応
      window.addEventListener("resize", () => {
        renderer.setSize(window.innerWidth, window.innerHeight);
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        gameCanvas.width = window.innerWidth;
        gameCanvas.height = window.innerHeight;
      });

      // === 2D避けゲー設定 ===
      const gameCanvas = document.getElementById("gameCanvas");
      const ctx = gameCanvas.getContext("2d");
      gameCanvas.width = window.innerWidth;
      gameCanvas.height = window.innerHeight;

      let player = {
        x: 50,
        y: gameCanvas.height / 2 - 20,
        width: 30,
        height: 30,
        speed: 6,
      };

      let obstacles = [];
      let obstacleTimer = 0;
      let obstacleInterval = 1500; // ms
      let lastTime = 0;

      let score = 0;
      let gameOver = false;

      const keys = {};

      window.addEventListener("keydown", (e) => {
        keys[e.key] = true;
      });
      window.addEventListener("keyup", (e) => {
        keys[e.key] = false;
      });

      function spawnObstacle() {
        const size = 20 + Math.random() * 40;
        const yPos = Math.random() * (gameCanvas.height - size);
        obstacles.push({
          x: gameCanvas.width + size,
          y: yPos,
          width: size,
          height: size,
          speed: 4 + Math.random() * 3,
        });
      }

      function update(delta) {
        if (gameOver) return;

        // プレイヤー移動（上下）
        if (keys["ArrowUp"] || keys["w"]) {
          player.y -= player.speed;
        }
        if (keys["ArrowDown"] || keys["s"]) {
          player.y += player.speed;
        }
        if (player.y < 0) player.y = 0;
        if (player.y + player.height > gameCanvas.height)
          player.y = gameCanvas.height - player.height;

        // 障害物移動
        obstacles.forEach((o) => (o.x -= o.speed));

        // 画面外の障害物削除
        obstacles = obstacles.filter((o) => o.x + o.width > 0);

        // 衝突判定
        for (let o of obstacles) {
          if (
            player.x < o.x + o.width &&
            player.x + player.width > o.x &&
            player.y < o.y + o.height &&
            player.y + player.height > o.y
          ) {
            gameOver = true;
          }
        }

        // 障害物生成タイミング
        obstacleTimer += delta;
        if (obstacleTimer > obstacleInterval) {
          spawnObstacle();
          obstacleTimer = 0;
          // 少しずつ間隔短くして難易度アップ
          if (obstacleInterval > 600) obstacleInterval -= 20;
        }

        if (!gameOver) {
          score += delta * 0.01;
        }
      }

      function draw() {
        ctx.clearRect(0, 0, gameCanvas.width, gameCanvas.height);

        // プレイヤー
        ctx.fillStyle = "#00aaff";
        ctx.fillRect(player.x, player.y, player.width, player.height);

        // 障害物
        ctx.fillStyle = "#ff4444";
        obstacles.forEach((o) => ctx.fillRect(o.x, o.y, o.width, o.height));

        if (gameOver) {
          ctx.fillStyle = "rgba(0,0,0,0.7)";
          ctx.fillRect(0, 0, gameCanvas.width, gameCanvas.height);

          ctx.fillStyle = "white";
          ctx.font = "48px sans-serif";
          ctx.textAlign = "center";
          ctx.fillText(
            "ゲームオーバー",
            gameCanvas.width / 2,
            gameCanvas.height / 2 - 20
          );
          ctx.font = "24px sans-serif";
          ctx.fillText(
            "ページを再読み込みしてリトライしてください",
            gameCanvas.width / 2,
            gameCanvas.height / 2 + 20
          );
        }
      }

      function gameLoop(timestamp = 0) {
        if (!lastTime) lastTime = timestamp;
        const delta = timestamp - lastTime;
        lastTime = timestamp;

        update(delta);
        draw();

        document.getElementById("score").textContent =
          "SCORE: " + Math.floor(score);

        requestAnimationFrame(gameLoop);
      }

      gameLoop();
    </script>
  </body>
</html>
